# CLI

Система содержит следующие классы:  
1) `Parser` — класс, отвечающий за разбор ввода и передачу получившейся `Command` дальше по конвейеру.  
2) `ProcessManager` — класс, который обрабатывает каждую строку команд, создаёт новых `Executor` и передаёт им команды `Command`.  
3) `Executor` — класс, который отвечает только за одну команду: либо через subprocess для внешних команд, либо через pure Python код для поддерживаемых команд (`wc`, `cat` и др.).  
4) `Command` — класс, который хранит команду. Это может быть либо список строк, либо кортеж (`command_name`, `command_args`, `flags_dict`).  
5) `Environment` — класс, который хранит и предоставляет доступ к переменным окружения, заданным во время выполнения скрипта.

## Пайплайн:

* Начало находится в `main.py`, где инициализируется `Environment` с переменными окружения из ОС, после чего запускается бесконечный цикл: читается следующая строка, определяется ее тип: новая переменная окружения или команда. Если новая переменная, то выставляем ее в `Environment`, иначе разбиваем по '|' и отдаем `ProcessManager`.  
* `ProcessManager` работает со списком команд пайплайна, последовательно выполняет их: делает подстановку переменных из `Environment`, дергает `Parser`, который парсит команду и создаёт объект `Command`
* `ProcessManager` создаёт `Executor`, передаёт ему команду и подставляет переменные окружения. При необходимости переназначает `stdin` и `stdout` на созданный через mkfifo пайп.  
* `Executor` определяет тип команды и либо использует встроенную реализацию, либо вызывает `subprocess`. Если происходит ошибка, то исполнение заканчивается с ненулевым кодом, который пробрасывается обратно в `Main`.  
* `Main` приняв код возврата очередной линии сообщает об ошибке при необходимости и переходит на новую итерацию.

## Детали реализации:

1) В функции `main` крутится бесконечный цикл, который считывает ввод, отдает на исполнение и принимает сообщения об ошибках.
2) Чтобы выйти нужно либо ввести Ctrl+D, либо команду exit. 
3) Чтобы определить тип команды, `main` после сплита по '|' смотрит на количество частей. При инициализации переменной часть должна быть ровно одна. Если она одна, то должна состоять из одного слова и содержать '='. ("name=value"). Во всех остальных случаях это команда, которую нужно отдать `Process Manager`.  
4) Объект класса `Executor` представляет логический процесс, отвечающий только за выполнение своей команды `Command`.  
5) Команды в пайплайне выполняются **последовательно слева направо**. Если в строке вызваны две команды через pipe, то следующая команда не будет вызвана до завершения предыдущей.    
6) `Executor` использует модуль `subprocess` для выполнения неизвестных команд и чистую Python-реализацию для встроенных.  
7) `Executor` взаимодействует с файловой системой для чтения файлов.
8) `Parser` создаёт разные представления команд в зависимости от их типа (известная / неизвестная): список или кортеж. Неизвестные команды запускаются через `subprocess`, которому достаточно списка токенов. А для поддерживаемых мы формируем тройку из **имени команды, списка ее аргументов, словаря[флаг , аргумент]**. 
9) Алгоритм `Parser`:
    * Делаем сплит по пробелам. Первый токен - имя команды.
    * Смотрим на имя команды. Если она не поддерживается, то делаем Command из списка токенов.
    * Если поддерживается, тогда идем по списку токенов окном в два токена. 
    * Флагами считается все вида либо '-x' (два символа), либо '--word'. Пишем два регулярных выражения на эти виды.
    * Если первый токен из окна является флагом, то второй потенциально является его аргументом (если он сам не флаг), тогда мы выставляем dict[`token1`] = `token2`. Если второй токен это тоже флаг, тогда dict[`token1`] = `None`. Если первый токен не флаг и он не был добавлен как аргумент флага на предыдущем шаге (заводим флажок под это), то это основной аргумент, который нужно добавить в список `args`. 
10) exit реализуется через exit(0) и моментально выходит из программы вне зависимости от пайпов.
11) Ненулевой код возврата завершает `pipeline` и пробрасывается по цепочке `Executor`-`ProcessManager`-`Main`, где дальше `main` выводит сообщение об ошибке и начинает новую итерацию.
12) Для реализации `pipe` мы каждый раз создаем файловый дескриптор, которым подменяем sys.stdout:
```
 stdin -> process1 -> fd1 -> process2 -> fd2 -> process3...
```
13) В случае, когда команды соединены через `pipe`, `ProcessManager` после очередной команды дополнительно вычитывает из последнего файлового дескриптора весь результат и складывает в `args` для следующей команды (т.к. флаги положить нельзя).
